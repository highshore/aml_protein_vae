# -*- coding: utf-8 -*-
"""Protein VAE

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WbsM203Mf5pZlMftprz6Yc3wX5zIoiMn
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import os

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F

##Protein sequence retreival
!pip install biopython pandas requests

from Bio import ExPASy, SwissProt, SeqIO, Entrez
from Bio.Blast import NCBIWWW, NCBIXML
import pandas as pd
import requests

#Protein of interest: Aqua porin  https://www.uniprot.org/uniprotkb/A0A251P855/entry
uniprot_id = "A0A251P855"

# Fetch FASTA directly from UniProt
url = f"https://www.uniprot.org/uniprot/{uniprot_id}.fasta"
response = requests.get(url)
fasta_seq = response.text

# Run BLASTP against NCBI nr database
result_handle = NCBIWWW.qblast("blastp", "nr",  fasta_seq, hitlist_size=500)

Entrez.email = "sean011016@gmail.com"  # required by NCBI

blast_record = NCBIXML.read(result_handle)
print(len(blast_record))

results = []
for alignment in blast_record.alignments[:100]:  # top 5 hits
    acc = alignment.accession

    # Fetch full FASTA sequence from NCBI using accession
    handle = Entrez.efetch(db="protein", id=acc, rettype="fasta", retmode="text")
    record = SeqIO.read(handle, "fasta")
    handle.close()

    results.append([acc, str(record.seq)])

# Make DataFrame and save as CSV
seq_df = pd.DataFrame(results, columns=["Accession_ID", "Full_FASTA"])

print(seq_df.head())

##Calculate average protein sequence length
#Retrieve sequences from CSV

seq_df["Seq_Length"] = seq_df["Full_FASTA"].apply(len)

# Calculate statistics
min_len = seq_df["Seq_Length"].min()
max_len = seq_df["Seq_Length"].max()
avg_len = seq_df["Seq_Length"].mean()

print("Minimum length:", min_len)
print("Maximum length:", max_len)
print("Average length:", avg_len)

##Fix sequence length by adding padding to both sides Padding Alphabet: "-"
'''
asdfasdfasdf-----
sadasdfasdfsdfasd
asdfadsfa--------
sdfasdfasdfadsf--
'''

# Suppose df["Full_FASTA"] contains your sequences
max_len = seq_df["Seq_Length"].max()

# Pad sequences with "-" on the right (to equal length)
#seq_df["Padded_FASTA"] = seq_df["Full_FASTA"].apply(lambda x: x.ljust(max_len, "-")) #To the right
seq_df["Padded_FASTA"] = seq_df["Full_FASTA"].apply(lambda x: x.rjust(max_len, "-")) #To the right
# Check lengths (all should be 333)
print(seq_df["Padded_FASTA"].apply(len).unique())
print(seq_df.head(10))
seq_df.to_csv("blast_hits.csv", index=False)

##Or just MSA

##Train Test Split 8:2
from sklearn.model_selection import train_test_split

# Assume df is your DataFrame
# For example, split 80% train, 20% test
train_df, test_df = train_test_split(seq_df, test_size=0.2, random_state=42)

print("Train size:", train_df.shape)
print("Test size:", test_df.shape)

seq_df.shape[0] ## Why only 50?

##One hot encoding: String -> Vector

# 2-d latent space, parameter count in same order of magnitude
latent_dims = 2
num_epochs = 7
batch_size = 128
capacity = 64
learning_rate = 1e-3
variational_beta = 1
use_gpu = True

import torchvision.transforms as transforms
from torch.utils.data import DataLoader
from torchvision.datasets import MNIST

img_transform = transforms.Compose([
    transforms.ToTensor()
])

train_dataset = MNIST(root='./data/MNIST', download=True, train=True, transform=img_transform)
train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

test_dataset = MNIST(root='./data/MNIST', download=True, train=False, transform=img_transform)
test_dataloader = DataLoader(test_dataset, batch_size=batch_size, shuffle=True)

##Revisions
#1D convolution filter
#Filter size?: Depends on the input size



class Encoder(nn.Module):
    def __init__(self):
        super(Encoder, self).__init__()
        c = capacity
        self.conv1 = nn.Conv2d(in_channels=1, out_channels=c, kernel_size=4, stride=2, padding=1) # out: c x 14 x 14
        self.conv2 = nn.Conv2d(in_channels=c, out_channels=c*2, kernel_size=4, stride=2, padding=1) # out: c x 7 x 7
        self.fc_mu = nn.Linear(in_features=c*2*7*7, out_features=latent_dims)
        self.fc_logvar = nn.Linear(in_features=c*2*7*7, out_features=latent_dims)

    def forward(self, x, verbose=False):
        x_1 = F.relu(self.conv1(x))
        x_2 = F.relu(self.conv2(x_1))
        x_3 = x_2.view(x_2.size(0), -1) # flatten batch of multi-channel feature maps to a batch of feature vectors
        x_mu = self.fc_mu(x_3)
        x_logvar = self.fc_logvar(x_3)

        if verbose:
          print(x_1.size(), x_2.size(), x_3.size(), x_mu.size(), x_logvar.size())

        return x_mu, x_logvar

class Decoder(nn.Module):
    def __init__(self):
        super(Decoder, self).__init__()
        c = capacity
        self.fc = nn.Linear(in_features=latent_dims, out_features=c*2*7*7)
        self.conv2 = nn.ConvTranspose2d(in_channels=c*2, out_channels=c, kernel_size=4, stride=2, padding=1)
        self.conv1 = nn.ConvTranspose2d(in_channels=c, out_channels=1, kernel_size=4, stride=2, padding=1)

    def forward(self, x, verbose=False):
        x_1 = self.fc(x)
        x_2 = x_1.view(x_1.size(0), capacity*2, 7, 7) # unflatten batch of feature vectors to a batch of multi-channel feature maps
        x_2 = F.relu(self.conv2(x_2))
        x_3 = torch.sigmoid(self.conv1(x_2)) # last layer before output is sigmoid, since we are using BCE as reconstruction loss

        if verbose:
          print(x_1.size(), x_2.size(), x_3.size())

        return x_3

"""**Pracice 1 (Gaussian Decoder).** In the previous example, a Bernoulli-type decoder was considered, where the `vae_loss` function and the `latent_sample `method of the `VariationalAutoencoder` class were defined. In this example, however, your objective is to implement the missing parts for a Gaussian-type decoder. Recall that for a Gaussian likelihood, the conditional distribution of data $x$ given latent variable $z$ is modeled as $p_{\theta}(x \mid z) = \mathcal{N}\big(x ; \mu_{\theta}(z), \sigma_x^2 I\big),$
so that the negative log-likelihood term is given by$-\log p_{\theta}(x \mid z) \;\approx\;
\frac{1}{2\sigma_x^2}\,\|x - \mu_{\theta}(z)\|_2^2 + \text{const}.$ Thus, the reconstruction loss becomes an $\ell_2$ loss (up to a scaling constant) between the original image $x$ and the decoder output $\mu_{\theta}(z)$.



*   Modify the decoder class so that it outputs the mean $\mu_{\theta}(z)$ of a Gaussian distribution rather than Bernoulli probabilities.
*   In the `vae_loss` function, replace the binary cross-entropy reconstruction term with the mean squared error (MSE) loss that corresponds to the Gaussian likelihood.
* Experiment with different values of $\sigma_x^2$ (e.g., fixed $\sigma_x^2=1$, or learnable) and observe how the reconstruction quality changes.


"""

## How is our loss defined?


class VariationalAutoencoder(nn.Module):
    def __init__(self):
        super(VariationalAutoencoder, self).__init__()
        self.encoder = Encoder()
        self.decoder = Decoder()

    def forward(self, x):
        latent_mu, latent_logvar = self.encoder(x)
        latent = self.latent_sample(latent_mu, latent_logvar)
        x_recon = self.decoder(latent)
        return x_recon, latent_mu, latent_logvar

    def latent_sample(self, mu, logvar):
        if self.training:
            # Implement the correct std and Gaussian noise for Gaussian-type decoders
            std = logvar.mul(0.5).exp_()
            eps = torch.empty_like(std).normal_()
            return eps.mul(std).add_(mu)
        else:
            return mu

def vae_loss(recon_x, x, mu, logvar):
    # Implement the correct reconstruction and regularization loss functions for Gaussian-type decoders
    recon_loss = F.mse_loss(recon_x, x, reduction='sum')
    kldivergence = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())
    return recon_loss + variational_beta * kldivergence

vae = VariationalAutoencoder()

device = torch.device("cuda:0" if use_gpu and torch.cuda.is_available() else "cpu")
vae = vae.to(device)

num_params = sum(p.numel() for p in vae.parameters() if p.requires_grad)
print('Number of parameters: %d' % num_params)

optimizer = torch.optim.Adam(params=vae.parameters(), lr=learning_rate, weight_decay=1e-5)

# set to training mode
vae.train()

train_loss_avg = []

print('Training ...')
for epoch in range(num_epochs):
    train_loss_avg.append(0)
    num_batches = 0

    for image_batch, _ in train_dataloader:

        image_batch = image_batch.to(device)

        # vae reconstruction
        image_batch_recon, latent_mu, latent_logvar = vae(image_batch)

        # reconstruction error
        loss = vae_loss(image_batch_recon, image_batch, latent_mu, latent_logvar)

        # backpropagation
        optimizer.zero_grad()
        loss.backward()

        # one step of the optmizer (using the gradients from backpropagation)
        optimizer.step()

        train_loss_avg[-1] += loss.item()
        num_batches += 1

    train_loss_avg[-1] /= num_batches
    print('Epoch [%d / %d] average reconstruction error: %f' % (epoch+1, num_epochs, train_loss_avg[-1]))

import matplotlib.pyplot as plt
plt.ion()

fig = plt.figure()
plt.plot(train_loss_avg)
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.show()

# set to evaluation mode
vae.eval()

test_loss_avg, num_batches = 0, 0
for image_batch, _ in test_dataloader:

    with torch.no_grad():

        image_batch = image_batch.to(device)

        # vae reconstruction
        image_batch_recon, latent_mu, latent_logvar = vae(image_batch)

        # reconstruction error
        loss = vae_loss(image_batch_recon, image_batch, latent_mu, latent_logvar)

        test_loss_avg += loss.item()
        num_batches += 1

test_loss_avg /= num_batches
print('average reconstruction error: %f' % (test_loss_avg))

"""**Pracice 2 (Spherical Linear Interpolation).**  In the previous interpolation function, the latent vectors were combined by simple linear interpolation:
\begin{equation} z_{\lambda}^{\mathrm{lin}} = (1-\lambda) z_1 + \lambda z_2,\qquad 0 \leq \lambda \leq 1.
\end{equation}

However, since the latent prior distribution of a Variational Autoencoder is the isotropic Gaussian $\mathcal{N}(0,I)$, a more natural interpolation scheme is the *spherical linear interpolation (Slerp)* defined as

\begin{equation}
z_{\lambda}^{\mathrm{slerp}}
= \frac{\sin\!\big((1-\lambda)\theta\big)}{\sin\theta}\,z_1
+ \frac{\sin\!\big(\lambda\theta\big)}{\sin\theta}\,z_2,
\quad
\theta = \cos^{-1}\!\left(\frac{z_1 \cdot z_2}{\|z_1\|\,\|z_2\|}\right).
\end{equation}

*   Implement the spherical linear interpolation function $\textrm{slerp}(z_1, z_2, \lambda)$ in PyTorch.
*   Compare the reconstructed digits obtained from linear interpolation and spherical interpolation for the same pair of images.
*    Discuss which interpolation better preserves the geometry of the Gaussian latent space and why.


"""

import numpy as np
import matplotlib.pyplot as plt
plt.ion()

import torchvision.utils

def to_img(x):
    x = x.clamp(0, 1)
    return x

def show_image(img):
    img = to_img(img)
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))

def visualise_output(images, model):

    with torch.no_grad():

        images = images.to(device)
        images, _, _ = model(images)
        images = images.cpu()
        images = to_img(images)
        np_imagegrid = torchvision.utils.make_grid(images[1:50], 10, 5).numpy()
        plt.imshow(np.transpose(np_imagegrid, (1, 2, 0)))
        plt.show()

vae.eval()


def interpolation(lambda1, model, img1, img2):

    with torch.no_grad():

        # latent vector of first image
        img1 = img1.to(device)
        latent_1, _ = model.encoder(img1)

        # latent vector of second image
        img2 = img2.to(device)
        latent_2, _ = model.encoder(img2)

        # Linear interpolation
        #inter_latent = lambda1* latent_1 + (1- lambda1) * latent_2 ######### LAMBDA 가 1보다 크게 되면 외분점이 나와서 이상한 결과가 나온다

        # Slerp
        dot = torch.sum(latent_1 * latent_2, dim=1, keepdim=True)
        norm_1 = torch.norm(latent_1, dim=1, keepdim=True)
        norm_2 = torch.norm(latent_2, dim=1, keepdim=True)
        theta = torch.acos(torch.clamp(dot / (norm_1 * norm_2), -1.0, 1.0))
        sin_theta = torch.sin(theta)
        w1 = torch.sin((1 - lambda1) * theta) / sin_theta
        w2 = torch.sin(lambda1 * theta) / sin_theta
        inter_latent = w1 * latent_1 + w2 * latent_2


        # reconstruct interpolated image
        inter_image = model.decoder(inter_latent)
        inter_image = inter_image.cpu()

        return inter_image

# sort part of test set by digit
digits = [[] for _ in range(10)]
for img_batch, label_batch in test_dataloader:
    for i in range(img_batch.size(0)):
        digits[label_batch[i]].append(img_batch[i:i+1])
    if sum(len(d) for d in digits) >= 1000:
        break;

# interpolation lambdas
lambda_range=np.linspace(0,1,10)

fig, axs = plt.subplots(2,5, figsize=(15, 6))
fig.subplots_adjust(hspace = .5, wspace=.001)
axs = axs.ravel()

for ind,l in enumerate(lambda_range):
    inter_image=interpolation(float(l), vae, digits[7][0], digits[1][0]) #####INTERPOLATE BETWEEN 7 AND 1

    inter_image = to_img(inter_image)

    image = inter_image.numpy()

    axs[ind].imshow(image[0,0,:,:], cmap='gray')
    axs[ind].set_title('lambda_val='+str(round(l,1)))
plt.show()

vae.eval()

with torch.no_grad():

    # sample latent vectors from the normal distribution
    latent = torch.randn(128, latent_dims, device=device)

    # reconstruct images from the latent vectors
    img_recon = vae.decoder(latent)
    img_recon = img_recon.cpu()

    fig, ax = plt.subplots(figsize=(5, 5))
    show_image(torchvision.utils.make_grid(img_recon.data[:100],10,5))
    plt.show()

# load a network that was trained with a 2d latent space
if latent_dims != 2:
    print('Please change the parameters to two latent dimensions.')

with torch.no_grad():

    # create a sample grid in 2d latent space
    latent_x = np.linspace(-1.5,1.5,20)
    latent_y = np.linspace(-1.5,1.5,20)
    latents = torch.FloatTensor(len(latent_y), len(latent_x), 2)
    for i, lx in enumerate(latent_x):
        for j, ly in enumerate(latent_y):
            latents[j, i, 0] = lx
            latents[j, i, 1] = ly
    latents = latents.view(-1, 2) # flatten grid into a batch

    # reconstruct images from the latent vectors
    latents = latents.to(device)
    image_recon = vae.decoder(latents)
    image_recon = image_recon.cpu()

    fig, ax = plt.subplots(figsize=(10, 10))
    show_image(torchvision.utils.make_grid(image_recon.data[:400],20,5))
    plt.show()