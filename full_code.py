# -*- coding: utf-8 -*-
"""Protein VAE

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WbsM203Mf5pZlMftprz6Yc3wX5zIoiMn
"""
##
# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import os

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from Bio import ExPASy, SwissProt, SeqIO, Entrez
from Bio.Blast import NCBIWWW, NCBIXML
import pandas as pd
import requests

#Proteins of interest - you can add multiple UniProt IDs here
# Aqua porin: https://www.uniprot.org/uniprotkb/A0A251P855/entry
uniprot_ids = [
    "A0A251P855",  # Aquaporin
    "P68871",    # Hemoglobin subunit beta
    "P01308",    # Insulin
]

print(f"[1/10] Processing {len(uniprot_ids)} protein(s)...")
print(f"  UniProt IDs: {', '.join(uniprot_ids)}")

Entrez.email = "sean011016@gmail.com"  # required by NCBI

# Collect all BLAST records from all proteins
all_blast_records = []

for protein_idx, uniprot_id in enumerate(uniprot_ids, 1):
    print(f"\n  [{protein_idx}/{len(uniprot_ids)}] Processing protein {uniprot_id}...")
    
    # Fetch FASTA directly from UniProt
    url = f"https://www.uniprot.org/uniprot/{uniprot_id}.fasta"
    try:
        response = requests.get(url)
        response.raise_for_status()
        fasta_seq = response.text
        
        if not fasta_seq or "Error" in fasta_seq:
            print(f"    ⚠ Warning: Failed to retrieve valid FASTA for {uniprot_id}, skipping...")
            continue
            
        print(f"    ✓ Retrieved FASTA sequence ({len(fasta_seq)} characters)")
    except Exception as e:
        print(f"    ⚠ Warning: Error fetching {uniprot_id}: {e}, skipping...")
        continue

    print(f"    Running BLASTP (this may take several minutes)...")
    # Run BLASTP against NCBI nr database
    try:
        result_handle = NCBIWWW.qblast("blastp", "nr", fasta_seq, hitlist_size=500)
        print(f"    ✓ BLAST search completed, parsing results...")
    except Exception as e:
        print(f"    ⚠ Warning: BLAST search failed for {uniprot_id}: {e}, skipping...")
        continue

    # Handle both single record and multiple records cases
    try:
        # First, try to read as a single record (most common case)
        blast_record = NCBIXML.read(result_handle)
        blast_records = [blast_record]
        print(f"    ✓ Parsed single BLAST record with {len(blast_record.alignments)} alignments")
    except (ValueError, AttributeError) as e:
        # If that fails, it might be multiple records
        print(f"    Single record parsing failed ({type(e).__name__}), trying multiple records...")
        # Save to temp file since we can't seek on web response
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.xml') as tmp:
            tmp.write(result_handle.read())
            tmp_path = tmp.name
        
        # Now parse from the file
        with open(tmp_path, 'r') as f:
            blast_records = list(NCBIXML.parse(f))
        
        # Clean up temp file
        os.unlink(tmp_path)
        
        total_alignments = sum(len(rec.alignments) for rec in blast_records)
        print(f"    ✓ Parsed {len(blast_records)} BLAST records with {total_alignments} total alignments")
    
    # Add to our collection
    all_blast_records.extend(blast_records)

print(f"\n[2/10] Collected BLAST results from {len(uniprot_ids)} protein(s)")
print(f"  Total BLAST records: {len(all_blast_records)}")

# Safety check: ensure we have records and alignments
if not all_blast_records:
    raise RuntimeError("No BLAST records found! All searches may have failed.")

total_available = sum(len(rec.alignments) for rec in all_blast_records)
if total_available == 0:
    raise RuntimeError("No alignments found in BLAST results!")

print(f"  Total alignments available: {total_available}")

print(f"\n[3/10] Fetching full sequences for top 100 unique BLAST hits...")

num_to_fetch = min(100, total_available)
print(f"  Will fetch up to {num_to_fetch} sequences from {total_available} available alignments")

results = []
seen_accessions = set()  # Track unique accessions to avoid duplicates
alignment_count = 0

for record_idx, blast_record in enumerate(all_blast_records):
    for alignment in blast_record.alignments:
        if len(results) >= 100:
            break
        
        acc = alignment.accession
        
        # Skip if we've already seen this accession
        if acc in seen_accessions:
            continue
        
        seen_accessions.add(acc)
        alignment_count += 1
        
        if alignment_count % 10 == 0:
            print(f"  Progress: {len(results)}/100 unique sequences retrieved...")

        try:
            # Fetch full FASTA sequence from NCBI using accession
            handle = Entrez.efetch(db="protein", id=acc, rettype="fasta", retmode="text")
            record = SeqIO.read(handle, "fasta")
            handle.close()
            results.append([acc, str(record.seq)])
        except Exception as e:
            print(f"  Warning: Failed to fetch sequence for {acc}: {e}")
            continue
    
    if len(results) >= 100:
        break

print(f"✓ Successfully retrieved {len(results)} unique protein sequences")

# Check if we have enough sequences to continue
if len(results) < 5:
    raise RuntimeError(f"Only retrieved {len(results)} sequences, need at least 5 for meaningful analysis!")

# Make DataFrame and save as CSV
seq_df = pd.DataFrame(results, columns=["Accession_ID", "Full_FASTA"])

print("\nFirst few sequences:")
print(seq_df.head())

##Calculate average protein sequence length
#Retrieve sequences from CSV

print("\n[4/10] Calculating sequence length statistics...")
seq_df["Seq_Length"] = seq_df["Full_FASTA"].apply(len)

# Calculate statistics
min_len = seq_df["Seq_Length"].min()
max_len = seq_df["Seq_Length"].max()
avg_len = seq_df["Seq_Length"].mean()

print(f"  Minimum length: {min_len}")
print(f"  Maximum length: {max_len}")
print(f"  Average length: {avg_len:.2f}")

##Fix sequence length by adding padding to both sides Padding Alphabet: "-"
'''
asdfasdfasdf-----
sadasdfasdfsdfasd
asdfadsfa--------
sdfasdfasdfadsf--
'''

# Suppose df["Full_FASTA"] contains your sequences
max_len = seq_df["Seq_Length"].max()

print(f"\n[5/10] Padding sequences to maximum length ({max_len})...")
# Pad sequences with "-" on the right (to equal length)
#seq_df["Padded_FASTA"] = seq_df["Full_FASTA"].apply(lambda x: x.ljust(max_len, "-")) #To the right
seq_df["Padded_FASTA"] = seq_df["Full_FASTA"].apply(lambda x: x.rjust(max_len, "-")) #To the right
# Check lengths (all should be 333)
unique_lengths = seq_df["Padded_FASTA"].apply(len).unique()
print(f"✓ All sequences padded to length: {unique_lengths}")
print("\nFirst 10 padded sequences:")
print(seq_df.head(10))
seq_df.to_csv("blast_hits.csv", index=False)
print(f"✓ Saved sequences to blast_hits.csv (source: {len(uniprot_ids)} protein(s))")

##Or just MSA

##Train Test Split 8:2
from sklearn.model_selection import train_test_split

print(f"\n[6/10] Splitting data into train/test sets (80/20 split)...")
# Assume df is your DataFrame
# For example, split 80% train, 20% test
train_df, test_df = train_test_split(seq_df, test_size=0.2, random_state=42)

print(f"✓ Train size: {train_df.shape}")
print(f"✓ Test size: {test_df.shape}")
print(f"  Total sequences: {seq_df.shape[0]}")

##One hot encoding: String -> Vector
##One hot encoding: String -> Vector

print(f"\n[7/10] One-hot encoding protein sequences...")
# Define amino acid alphabet (incl. gap '-')
aa_alphabet = "ACDEFGHIKLMNPQRSTVWY-X"
aa_to_int = {aa: i for i, aa in enumerate(aa_alphabet)}
vocab_size = len(aa_alphabet)
print(f"  Amino acid alphabet size: {vocab_size}")


def one_hot_encode_sequence(seq, max_len=333):
    # Convert each character to an integer
    int_encoded = [aa_to_int.get(aa, aa_to_int["X"]) for aa in seq]
    
    # One-hot encode
    one_hot = np.zeros((max_len, vocab_size), dtype=np.int8)
    for i, idx in enumerate(int_encoded):
        one_hot[i, idx] = 1
    return one_hot

# One-hot encode all sequences in training set
train_encoded = np.array([one_hot_encode_sequence(seq, max_len=333) 
                          for seq in train_df["Padded_FASTA"]])

print(f"✓ Training data shape: {train_encoded.shape}")
# (num_sequences, 333, vocab_size)


train_encoded_flat = train_encoded.reshape(train_encoded.shape[0], -1)
print(f"✓ Flattened shape: {train_encoded_flat.shape}")
# (num_sequences, 333*22)






# 2-d latent space, parameter count in same order of magnitude
latent_dims = 2
num_epochs = 7
batch_size = 128
capacity = 64
learning_rate = 1e-3
variational_beta = 1
use_gpu = True

print(f"\n[8/10] Setting up VAE model and loading MNIST data...")
print(f"  Model parameters:")
print(f"    - Latent dimensions: {latent_dims}")
print(f"    - Epochs: {num_epochs}")
print(f"    - Batch size: {batch_size}")
print(f"    - Learning rate: {learning_rate}")

import torchvision.transforms as transforms
from torch.utils.data import DataLoader
from torchvision.datasets import MNIST

img_transform = transforms.Compose([
    transforms.ToTensor()
])

train_dataset = MNIST(root='./data/MNIST', download=True, train=True, transform=img_transform)
train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

test_dataset = MNIST(root='./data/MNIST', download=True, train=False, transform=img_transform)
test_dataloader = DataLoader(test_dataset, batch_size=batch_size, shuffle=True)
print(f"✓ MNIST data loaded: {len(train_dataset)} training, {len(test_dataset)} test images")

##Revisions
#1D convolution filter
#Filter size?: Depends on the input size



class Encoder(nn.Module):
    def __init__(self):
        super(Encoder, self).__init__()
        c = capacity
        self.conv1 = nn.Conv2d(in_channels=1, out_channels=c, kernel_size=4, stride=2, padding=1) # out: c x 14 x 14
        self.conv2 = nn.Conv2d(in_channels=c, out_channels=c*2, kernel_size=4, stride=2, padding=1) # out: c x 7 x 7
        self.fc_mu = nn.Linear(in_features=c*2*7*7, out_features=latent_dims)
        self.fc_logvar = nn.Linear(in_features=c*2*7*7, out_features=latent_dims)

    def forward(self, x, verbose=False):
        x_1 = F.relu(self.conv1(x))
        x_2 = F.relu(self.conv2(x_1))
        x_3 = x_2.view(x_2.size(0), -1) # flatten batch of multi-channel feature maps to a batch of feature vectors
        x_mu = self.fc_mu(x_3)
        x_logvar = self.fc_logvar(x_3)

        if verbose:
          print(x_1.size(), x_2.size(), x_3.size(), x_mu.size(), x_logvar.size())

        return x_mu, x_logvar

class Decoder(nn.Module):
    def __init__(self):
        super(Decoder, self).__init__()
        c = capacity
        self.fc = nn.Linear(in_features=latent_dims, out_features=c*2*7*7)
        self.conv2 = nn.ConvTranspose2d(in_channels=c*2, out_channels=c, kernel_size=4, stride=2, padding=1)
        self.conv1 = nn.ConvTranspose2d(in_channels=c, out_channels=1, kernel_size=4, stride=2, padding=1)

    def forward(self, x, verbose=False):
        x_1 = self.fc(x)
        x_2 = x_1.view(x_1.size(0), capacity*2, 7, 7) # unflatten batch of feature vectors to a batch of multi-channel feature maps
        x_2 = F.relu(self.conv2(x_2))
        x_3 = torch.sigmoid(self.conv1(x_2)) # last layer before output is sigmoid, since we are using BCE as reconstruction loss

        if verbose:
          print(x_1.size(), x_2.size(), x_3.size())

        return x_3

"""**Pracice 1 (Gaussian Decoder).** In the previous example, a Bernoulli-type decoder was considered, where the `vae_loss` function and the `latent_sample `method of the `VariationalAutoencoder` class were defined. In this example, however, your objective is to implement the missing parts for a Gaussian-type decoder. Recall that for a Gaussian likelihood, the conditional distribution of data $x$ given latent variable $z$ is modeled as $p_{\theta}(x \mid z) = \mathcal{N}\big(x ; \mu_{\theta}(z), \sigma_x^2 I\big),$
so that the negative log-likelihood term is given by$-\log p_{\theta}(x \mid z) \;\approx\;
\frac{1}{2\sigma_x^2}\,\|x - \mu_{\theta}(z)\|_2^2 + \text{const}.$ Thus, the reconstruction loss becomes an $\ell_2$ loss (up to a scaling constant) between the original image $x$ and the decoder output $\mu_{\theta}(z)$.



*   Modify the decoder class so that it outputs the mean $\mu_{\theta}(z)$ of a Gaussian distribution rather than Bernoulli probabilities.
*   In the `vae_loss` function, replace the binary cross-entropy reconstruction term with the mean squared error (MSE) loss that corresponds to the Gaussian likelihood.
* Experiment with different values of $\sigma_x^2$ (e.g., fixed $\sigma_x^2=1$, or learnable) and observe how the reconstruction quality changes.


"""

## How is our loss defined?


class VariationalAutoencoder(nn.Module):
    def __init__(self):
        super(VariationalAutoencoder, self).__init__()
        self.encoder = Encoder()
        self.decoder = Decoder()

    def forward(self, x):
        latent_mu, latent_logvar = self.encoder(x)
        latent = self.latent_sample(latent_mu, latent_logvar)
        x_recon = self.decoder(latent)
        return x_recon, latent_mu, latent_logvar

    def latent_sample(self, mu, logvar):
        if self.training:
            # Implement the correct std and Gaussian noise for Gaussian-type decoders
            std = logvar.mul(0.5).exp_()
            eps = torch.empty_like(std).normal_()
            return eps.mul(std).add_(mu)
        else:
            return mu

def vae_loss(recon_x, x, mu, logvar):
    # Implement the correct reconstruction and regularization loss functions for Gaussian-type decoders
    recon_loss = F.mse_loss(recon_x, x, reduction='sum')
    kldivergence = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())
    return recon_loss + variational_beta * kldivergence

vae = VariationalAutoencoder()

device = torch.device("cuda:0" if use_gpu and torch.cuda.is_available() else "cpu")
vae = vae.to(device)

num_params = sum(p.numel() for p in vae.parameters() if p.requires_grad)
print(f'✓ VAE model created with {num_params:,} trainable parameters')
print(f'  Using device: {device}')

optimizer = torch.optim.Adam(params=vae.parameters(), lr=learning_rate, weight_decay=1e-5)

# set to training mode
vae.train()

train_loss_avg = []

print(f'\n[9/10] Training VAE model for {num_epochs} epochs...')
for epoch in range(num_epochs):
    train_loss_avg.append(0)
    num_batches = 0

    for image_batch, _ in train_dataloader:

        image_batch = image_batch.to(device)

        # vae reconstruction
        image_batch_recon, latent_mu, latent_logvar = vae(image_batch)

        # reconstruction error
        loss = vae_loss(image_batch_recon, image_batch, latent_mu, latent_logvar)

        # backpropagation
        optimizer.zero_grad()
        loss.backward()

        # one step of the optmizer (using the gradients from backpropagation)
        optimizer.step()

        train_loss_avg[-1] += loss.item()
        num_batches += 1

    train_loss_avg[-1] /= num_batches
    print('  Epoch [%d / %d] average reconstruction error: %.2f' % (epoch+1, num_epochs, train_loss_avg[-1]))

print('✓ Training completed!')

import matplotlib.pyplot as plt
plt.ion()

print('\n  Plotting training loss curve...')
fig = plt.figure()
plt.plot(train_loss_avg)
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.show()

print(f'\n[10/10] Evaluating model on test set...')
# set to evaluation mode
vae.eval()

test_loss_avg, num_batches = 0, 0
for image_batch, _ in test_dataloader:

    with torch.no_grad():

        image_batch = image_batch.to(device)

        # vae reconstruction
        image_batch_recon, latent_mu, latent_logvar = vae(image_batch)

        # reconstruction error
        loss = vae_loss(image_batch_recon, image_batch, latent_mu, latent_logvar)

        test_loss_avg += loss.item()
        num_batches += 1

test_loss_avg /= num_batches
print(f'✓ Test set average reconstruction error: {test_loss_avg:.2f}')

"""**Pracice 2 (Spherical Linear Interpolation).**  In the previous interpolation function, the latent vectors were combined by simple linear interpolation:
\begin{equation} z_{\lambda}^{\mathrm{lin}} = (1-\lambda) z_1 + \lambda z_2,\qquad 0 \leq \lambda \leq 1.
\end{equation}

However, since the latent prior distribution of a Variational Autoencoder is the isotropic Gaussian $\mathcal{N}(0,I)$, a more natural interpolation scheme is the *spherical linear interpolation (Slerp)* defined as

\begin{equation}
z_{\lambda}^{\mathrm{slerp}}
= \frac{\sin\!\big((1-\lambda)\theta\big)}{\sin\theta}\,z_1
+ \frac{\sin\!\big(\lambda\theta\big)}{\sin\theta}\,z_2,
\quad
\theta = \cos^{-1}\!\left(\frac{z_1 \cdot z_2}{\|z_1\|\,\|z_2\|}\right).
\end{equation}

*   Implement the spherical linear interpolation function $\textrm{slerp}(z_1, z_2, \lambda)$ in PyTorch.
*   Compare the reconstructed digits obtained from linear interpolation and spherical interpolation for the same pair of images.
*    Discuss which interpolation better preserves the geometry of the Gaussian latent space and why.


"""

import numpy as np
import matplotlib.pyplot as plt
plt.ion()

import torchvision.utils

def to_img(x):
    x = x.clamp(0, 1)
    return x

def show_image(img):
    img = to_img(img)
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))

def visualise_output(images, model):

    with torch.no_grad():

        images = images.to(device)
        images, _, _ = model(images)
        images = images.cpu()
        images = to_img(images)
        np_imagegrid = torchvision.utils.make_grid(images[1:50], 10, 5).numpy()
        plt.imshow(np.transpose(np_imagegrid, (1, 2, 0)))
        plt.show()

print('\n  Generating visualizations and interpolations...')

vae.eval()


def interpolation(lambda1, model, img1, img2):

    with torch.no_grad():

        # latent vector of first image
        img1 = img1.to(device)
        latent_1, _ = model.encoder(img1)

        # latent vector of second image
        img2 = img2.to(device)
        latent_2, _ = model.encoder(img2)

        # Linear interpolation
        #inter_latent = lambda1* latent_1 + (1- lambda1) * latent_2 ######### LAMBDA 가 1보다 크게 되면 외분점이 나와서 이상한 결과가 나온다

        # Slerp
        dot = torch.sum(latent_1 * latent_2, dim=1, keepdim=True)
        norm_1 = torch.norm(latent_1, dim=1, keepdim=True)
        norm_2 = torch.norm(latent_2, dim=1, keepdim=True)
        theta = torch.acos(torch.clamp(dot / (norm_1 * norm_2), -1.0, 1.0))
        sin_theta = torch.sin(theta)
        w1 = torch.sin((1 - lambda1) * theta) / sin_theta
        w2 = torch.sin(lambda1 * theta) / sin_theta
        inter_latent = w1 * latent_1 + w2 * latent_2


        # reconstruct interpolated image
        inter_image = model.decoder(inter_latent)
        inter_image = inter_image.cpu()

        return inter_image

print('  Creating interpolation between digits 7 and 1...')
# sort part of test set by digit
digits = [[] for _ in range(10)]
for img_batch, label_batch in test_dataloader:
    for i in range(img_batch.size(0)):
        digits[label_batch[i]].append(img_batch[i:i+1])
    if sum(len(d) for d in digits) >= 1000:
        break;

# interpolation lambdas
lambda_range=np.linspace(0,1,10)

fig, axs = plt.subplots(2,5, figsize=(15, 6))
fig.subplots_adjust(hspace = .5, wspace=.001)
axs = axs.ravel()

for ind,l in enumerate(lambda_range):
    inter_image=interpolation(float(l), vae, digits[7][0], digits[1][0]) #####INTERPOLATE BETWEEN 7 AND 1

    inter_image = to_img(inter_image)

    image = inter_image.numpy()

    axs[ind].imshow(image[0,0,:,:], cmap='gray')
    axs[ind].set_title('lambda_val='+str(round(l,1)))
plt.show()
print('  ✓ Interpolation visualization created')

vae.eval()

print('  Generating random samples from latent space...')
with torch.no_grad():

    # sample latent vectors from the normal distribution
    latent = torch.randn(128, latent_dims, device=device)

    # reconstruct images from the latent vectors
    img_recon = vae.decoder(latent)
    img_recon = img_recon.cpu()

    fig, ax = plt.subplots(figsize=(5, 5))
    show_image(torchvision.utils.make_grid(img_recon.data[:100],10,5))
    plt.show()
print('  ✓ Random samples visualization created')

# load a network that was trained with a 2d latent space
if latent_dims != 2:
    print('Please change the parameters to two latent dimensions.')
else:
    print('  Creating 2D latent space grid visualization...')

with torch.no_grad():

    # create a sample grid in 2d latent space
    latent_x = np.linspace(-1.5,1.5,20)
    latent_y = np.linspace(-1.5,1.5,20)
    latents = torch.FloatTensor(len(latent_y), len(latent_x), 2)
    for i, lx in enumerate(latent_x):
        for j, ly in enumerate(latent_y):
            latents[j, i, 0] = lx
            latents[j, i, 1] = ly
    latents = latents.view(-1, 2) # flatten grid into a batch

    # reconstruct images from the latent vectors
    latents = latents.to(device)
    image_recon = vae.decoder(latents)
    image_recon = image_recon.cpu()

    fig, ax = plt.subplots(figsize=(10, 10))
    show_image(torchvision.utils.make_grid(image_recon.data[:400],20,5))
    plt.show()

print('\n' + '='*60)
print('  ALL TASKS COMPLETED SUCCESSFULLY!')
print('='*60)
